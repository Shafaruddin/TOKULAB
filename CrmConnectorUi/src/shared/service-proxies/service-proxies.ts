//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AdminServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    getStatusFlags(adminToken: any): Observable<StatusFlagDto[]> {
        let url_ = this.baseUrl + "/api/Admin/GetStatusFlags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatusFlags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatusFlags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StatusFlagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StatusFlagDto[]>;
        }));
    }

    protected processGetStatusFlags(response: HttpResponseBase): Observable<StatusFlagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusFlagDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatusFlagDto[]>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @param body (optional) 
     * @return Success
     */
    upsertStatusFlags(adminToken: any, body: StatusFlagDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/UpsertStatusFlags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertStatusFlags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertStatusFlags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpsertStatusFlags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param accountStatusCode (optional) 
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    deleteStatusFlags(accountStatusCode: string | undefined, adminToken: any): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/DeleteStatusFlags?";
        if (accountStatusCode === null)
            throw new Error("The parameter 'accountStatusCode' cannot be null.");
        else if (accountStatusCode !== undefined)
            url_ += "accountStatusCode=" + encodeURIComponent("" + accountStatusCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStatusFlags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStatusFlags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteStatusFlags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @param file (optional) 
     * @return Success
     */
    uploadRetailersExcelFile(adminToken: any, file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/UploadRetailersExcelFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadRetailersExcelFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadRetailersExcelFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadRetailersExcelFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    clearCategoryAndAdhocCriteriaCache(adminToken: any): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Admin/ClearCategoryAndAdhocCriteriaCache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCategoryAndAdhocCriteriaCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCategoryAndAdhocCriteriaCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClearCategoryAndAdhocCriteriaCache(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    clearStatusFlagsCache(adminToken: any): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Admin/ClearStatusFlagsCache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearStatusFlagsCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearStatusFlagsCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClearStatusFlagsCache(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    clearRetailersCache(adminToken: any): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Admin/ClearRetailersCache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearRetailersCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearRetailersCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processClearRetailersCache(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param adminToken "AdminToken" Header. Example: "c6a7fa06-2d7a-4b62-b37d-c37d5ab334ca"
     * @return Success
     */
    upsertUser(username: string, password: string, adminToken: any): Observable<void> {
        let url_ = this.baseUrl + "/api/Admin/UpsertUser?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (password === undefined || password === null)
            throw new Error("The parameter 'password' must be defined and cannot be null.");
        else
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "AdminToken": adminToken !== undefined && adminToken !== null ? "" + adminToken : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpsertUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpsertUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpsertUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    index(): Observable<string> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class RetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRetailByContactPost(body: RetailContactSearchByContactInputDto | undefined): Observable<RetailOutputDto> {
        let url_ = this.baseUrl + "/api/Retail/GetRetailByContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailByContactPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailByContactPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailOutputDto>;
        }));
    }

    protected processGetRetailByContactPost(response: HttpResponseBase): Observable<RetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailOutputDto>(null as any);
    }

    /**
     * @return Success
     */
    getRetailByContactGet(contact: string): Observable<RetailOutputDto> {
        let url_ = this.baseUrl + "/api/Retail/GetRetailByContact?";
        if (contact === undefined || contact === null)
            throw new Error("The parameter 'contact' must be defined and cannot be null.");
        else
            url_ += "contact=" + encodeURIComponent("" + contact) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailByContactGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailByContactGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailOutputDto>;
        }));
    }

    protected processGetRetailByContactGet(response: HttpResponseBase): Observable<RetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailOutputDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRetailByRetailPost(body: RetailContactSearchByRetailInputDto | undefined): Observable<RetailOutputDto> {
        let url_ = this.baseUrl + "/api/Retail/GetRetailByRetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailByRetailPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailByRetailPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailOutputDto>;
        }));
    }

    protected processGetRetailByRetailPost(response: HttpResponseBase): Observable<RetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailOutputDto>(null as any);
    }

    /**
     * @return Success
     */
    getRetailByRetailGet(retail: string): Observable<RetailOutputDto> {
        let url_ = this.baseUrl + "/api/Retail/GetRetailByRetail?";
        if (retail === undefined || retail === null)
            throw new Error("The parameter 'retail' must be defined and cannot be null.");
        else
            url_ += "retail=" + encodeURIComponent("" + retail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRetailByRetailGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRetailByRetailGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailOutputDto>;
        }));
    }

    protected processGetRetailByRetailGet(response: HttpResponseBase): Observable<RetailOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailOutputDto>(null as any);
    }
}

@Injectable()
export class SVCSConnectorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    getCustomer(authorization: any | undefined, body: GetCustomerInputDto | undefined): Observable<GetCustomerOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/GetCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCustomerOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCustomerOutputDto>;
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<GetCustomerOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    findCustomer(authorization: any | undefined, body: FindCustomerInputDto | undefined): Observable<FindCustomerOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/FindCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindCustomer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FindCustomerOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FindCustomerOutputDto>;
        }));
    }

    protected processFindCustomer(response: HttpResponseBase): Observable<FindCustomerOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindCustomerOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FindCustomerOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    createCase(authorization: any | undefined, body: CreateCaseInputDto | undefined): Observable<CreateUpdateCaseOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/CreateCase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateCaseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateCaseOutputDto>;
        }));
    }

    protected processCreateCase(response: HttpResponseBase): Observable<CreateUpdateCaseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateCaseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUpdateCaseOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    updateCase(authorization: any | undefined, body: UpdateCaseInputDto | undefined): Observable<CreateUpdateCaseOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/UpdateCase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUpdateCaseOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUpdateCaseOutputDto>;
        }));
    }

    protected processUpdateCase(response: HttpResponseBase): Observable<CreateUpdateCaseOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUpdateCaseOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUpdateCaseOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    getCaseAndActivitiesHistory(authorization: any | undefined, body: GetCaseAndActivitiesHistoryInputDto | undefined): Observable<GetCaseAndActivitiesHistoryOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/GetCaseAndActivitiesHistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAndActivitiesHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAndActivitiesHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCaseAndActivitiesHistoryOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCaseAndActivitiesHistoryOutputDto>;
        }));
    }

    protected processGetCaseAndActivitiesHistory(response: HttpResponseBase): Observable<GetCaseAndActivitiesHistoryOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCaseAndActivitiesHistoryOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCaseAndActivitiesHistoryOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @return Success
     */
    getCategoryAndCriteria(authorization: any | undefined): Observable<GetCategoryAndCriteriaOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/GetCategoryAndCriteria";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryAndCriteria(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryAndCriteria(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCategoryAndCriteriaOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCategoryAndCriteriaOutputDto>;
        }));
    }

    protected processGetCategoryAndCriteria(response: HttpResponseBase): Observable<GetCategoryAndCriteriaOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCategoryAndCriteriaOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCategoryAndCriteriaOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    generateOTP(authorization: any | undefined, body: GenerateOTPInputDto | undefined): Observable<GenerateOTPOutputDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/GenerateOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateOTPOutputDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateOTPOutputDto>;
        }));
    }

    protected processGenerateOTP(response: HttpResponseBase): Observable<GenerateOTPOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenerateOTPOutputDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenerateOTPOutputDto>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    challengeOTP(authorization: any | undefined, body: ChallengeOTPInputDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SVCSConnector/ChallengeOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChallengeOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChallengeOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChallengeOTP(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    shortenUpdateCaseUrl(authorization: any | undefined, body: ShortenUpdateCaseUrlDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/SVCSConnector/ShortenUpdateCaseUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShortenUpdateCaseUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShortenUpdateCaseUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processShortenUpdateCaseUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    getShortenUrl(authorization: any | undefined, body: GetShortenedUrlInputDto | undefined): Observable<ShortenUpdateCaseUrlDto> {
        let url_ = this.baseUrl + "/api/SVCSConnector/GetShortenUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortenUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortenUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortenUpdateCaseUrlDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortenUpdateCaseUrlDto>;
        }));
    }

    protected processGetShortenUrl(response: HttpResponseBase): Observable<ShortenUpdateCaseUrlDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortenUpdateCaseUrlDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortenUpdateCaseUrlDto>(null as any);
    }
}

@Injectable()
export class AutoSaveCaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param authorization (optional) Example: "Basic XXXXXXXX"
     * @param body (optional) 
     * @return Success
     */
    autoSaveCase(caseId: string, authorization: any | undefined, body: UpdateCaseAutoSaveInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SVCSConnector/AutoSaveCase/AutoSaveCaseAsync/{caseId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoSaveCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoSaveCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAutoSaveCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class AdhocCriterion implements IAdhocCriterion {
    name!: string | undefined;
    status!: string | undefined;
    modifiedDate!: string | undefined;
    adhocCriteriaId!: string;

    constructor(data?: IAdhocCriterion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.status = _data["status"];
            this.modifiedDate = _data["modifiedDate"];
            this.adhocCriteriaId = _data["adhocCriteriaId"];
        }
    }

    static fromJS(data: any): AdhocCriterion {
        data = typeof data === 'object' ? data : {};
        let result = new AdhocCriterion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["status"] = this.status;
        data["modifiedDate"] = this.modifiedDate;
        data["adhocCriteriaId"] = this.adhocCriteriaId;
        return data;
    }
}

export interface IAdhocCriterion {
    name: string | undefined;
    status: string | undefined;
    modifiedDate: string | undefined;
    adhocCriteriaId: string;
}

export enum CaseStatusInputEnum {
    InProgress = "InProgress",
    Resolved = "Resolved",
}

export class Category implements ICategory {
    name!: string | undefined;
    type!: string | undefined;
    categoryId!: string;
    relatedCategory1ID!: string | undefined;
    relatedCategory2ID!: string | undefined;
    status!: string | undefined;
    modifiedDate!: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.categoryId = _data["categoryId"];
            this.relatedCategory1ID = _data["relatedCategory1ID"];
            this.relatedCategory2ID = _data["relatedCategory2ID"];
            this.status = _data["status"];
            this.modifiedDate = _data["modifiedDate"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["categoryId"] = this.categoryId;
        data["relatedCategory1ID"] = this.relatedCategory1ID;
        data["relatedCategory2ID"] = this.relatedCategory2ID;
        data["status"] = this.status;
        data["modifiedDate"] = this.modifiedDate;
        return data;
    }
}

export interface ICategory {
    name: string | undefined;
    type: string | undefined;
    categoryId: string;
    relatedCategory1ID: string | undefined;
    relatedCategory2ID: string | undefined;
    status: string | undefined;
    modifiedDate: string | undefined;
}

export class ChallengeOTPInputDto implements IChallengeOTPInputDto {
    mobile!: string;
    otpValidate!: string;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IChallengeOTPInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobile = _data["mobile"];
            this.otpValidate = _data["otpValidate"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): ChallengeOTPInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChallengeOTPInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobile"] = this.mobile;
        data["otpValidate"] = this.otpValidate;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IChallengeOTPInputDto {
    mobile: string;
    otpValidate: string;
    triggeredFrom: string;
    triggeredBy: string;
}

export enum ContactModeInputEnum {
    Inbound = "Inbound",
    Outbound = "Outbound",
}

export class CreateCaseInputDto implements ICreateCaseInputDto {
    customerGUID!: string;
    caseTitle!: string;
    caseDetails!: string;
    systemAuthenticated!: boolean;
    dateTimeReceived!: DateTime;
    ipccCallExtensionID!: string;
    primaryCaseOfficer!: string;
    owner!: string;
    caseCategory1!: string;
    caseCategory2!: string;
    caseCategory3!: string;
    contactMode!: ContactModeInputEnum;
    createdOn!: DateTime;
    createdBy!: string;
    modifiedBy!: string;
    callBack!: boolean;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: ICreateCaseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerGUID = _data["customerGUID"];
            this.caseTitle = _data["caseTitle"];
            this.caseDetails = _data["caseDetails"];
            this.systemAuthenticated = _data["systemAuthenticated"];
            this.dateTimeReceived = _data["dateTimeReceived"] ? DateTime.fromISO(_data["dateTimeReceived"].toString()) : <any>undefined;
            this.ipccCallExtensionID = _data["ipccCallExtensionID"];
            this.primaryCaseOfficer = _data["primaryCaseOfficer"];
            this.owner = _data["owner"];
            this.caseCategory1 = _data["caseCategory1"];
            this.caseCategory2 = _data["caseCategory2"];
            this.caseCategory3 = _data["caseCategory3"];
            this.contactMode = _data["contactMode"];
            this.createdOn = _data["createdOn"] ? DateTime.fromISO(_data["createdOn"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.callBack = _data["callBack"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): CreateCaseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCaseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGUID"] = this.customerGUID;
        data["caseTitle"] = this.caseTitle;
        data["caseDetails"] = this.caseDetails;
        data["systemAuthenticated"] = this.systemAuthenticated;
        data["dateTimeReceived"] = this.dateTimeReceived ? this.dateTimeReceived.toString() : <any>undefined;
        data["ipccCallExtensionID"] = this.ipccCallExtensionID;
        data["primaryCaseOfficer"] = this.primaryCaseOfficer;
        data["owner"] = this.owner;
        data["caseCategory1"] = this.caseCategory1;
        data["caseCategory2"] = this.caseCategory2;
        data["caseCategory3"] = this.caseCategory3;
        data["contactMode"] = this.contactMode;
        data["createdOn"] = this.createdOn ? this.createdOn.toString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["callBack"] = this.callBack;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface ICreateCaseInputDto {
    customerGUID: string;
    caseTitle: string;
    caseDetails: string;
    systemAuthenticated: boolean;
    dateTimeReceived: DateTime;
    ipccCallExtensionID: string;
    primaryCaseOfficer: string;
    owner: string;
    caseCategory1: string;
    caseCategory2: string;
    caseCategory3: string;
    contactMode: ContactModeInputEnum;
    createdOn: DateTime;
    createdBy: string;
    modifiedBy: string;
    callBack: boolean;
    triggeredFrom: string;
    triggeredBy: string;
}

export class CreateUpdateCaseOutputDto implements ICreateUpdateCaseOutputDto {
    caseID!: string | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: ICreateUpdateCaseOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseID = _data["caseID"];
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUpdateCaseOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateCaseOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseID"] = this.caseID;
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateUpdateCaseOutputDto {
    caseID: string | undefined;
    returnStatus: ReturnStatusDto;
}

export class Customer implements ICustomer {
    customerName!: string | undefined;
    idNumber!: string | undefined;
    accountNo!: string | undefined;
    mobileNo!: string | undefined;
    emailAddress!: string | undefined;
    customerGUID!: string | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["customerName"];
            this.idNumber = _data["idNumber"];
            this.accountNo = _data["accountNo"];
            this.mobileNo = _data["mobileNo"];
            this.emailAddress = _data["emailAddress"];
            this.customerGUID = _data["customerGUID"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerName"] = this.customerName;
        data["idNumber"] = this.idNumber;
        data["accountNo"] = this.accountNo;
        data["mobileNo"] = this.mobileNo;
        data["emailAddress"] = this.emailAddress;
        data["customerGUID"] = this.customerGUID;
        return data;
    }
}

export interface ICustomer {
    customerName: string | undefined;
    idNumber: string | undefined;
    accountNo: string | undefined;
    mobileNo: string | undefined;
    emailAddress: string | undefined;
    customerGUID: string | undefined;
}

export enum DataSetEnum {
    Subset = "Subset",
    FullData = "FullData",
}

export class FindCustomerInputDto implements IFindCustomerInputDto {
    name!: string | undefined;
    idNumber!: string | undefined;
    accountNumber!: string | undefined;
    mobileNo!: string | undefined;
    emailAddress!: string | undefined;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IFindCustomerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.idNumber = _data["idNumber"];
            this.accountNumber = _data["accountNumber"];
            this.mobileNo = _data["mobileNo"];
            this.emailAddress = _data["emailAddress"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): FindCustomerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCustomerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["idNumber"] = this.idNumber;
        data["accountNumber"] = this.accountNumber;
        data["mobileNo"] = this.mobileNo;
        data["emailAddress"] = this.emailAddress;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IFindCustomerInputDto {
    name: string | undefined;
    idNumber: string | undefined;
    accountNumber: string | undefined;
    mobileNo: string | undefined;
    emailAddress: string | undefined;
    triggeredFrom: string;
    triggeredBy: string;
}

export class FindCustomerOutputDto implements IFindCustomerOutputDto {
    customers!: Customer[] | undefined;
    totalRecordsFound!: string | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: IFindCustomerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(Customer.fromJS(item));
            }
            this.totalRecordsFound = _data["totalRecordsFound"];
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FindCustomerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindCustomerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        data["totalRecordsFound"] = this.totalRecordsFound;
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFindCustomerOutputDto {
    customers: Customer[] | undefined;
    totalRecordsFound: string | undefined;
    returnStatus: ReturnStatusDto;
}

export class GenerateOTPInputDto implements IGenerateOTPInputDto {
    mobile!: string;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IGenerateOTPInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mobile = _data["mobile"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): GenerateOTPInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateOTPInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobile"] = this.mobile;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IGenerateOTPInputDto {
    mobile: string;
    triggeredFrom: string;
    triggeredBy: string;
}

export class GenerateOTPOutputDto implements IGenerateOTPOutputDto {
    canRetry!: boolean;
    retryAfterSeconds!: number;
    shouldChangeMobileNumber!: boolean;
    otpSent!: boolean;
    secondsRemaining!: number;
    resultCode!: string | undefined;
    resultMessage!: string | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: IGenerateOTPOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canRetry = _data["canRetry"];
            this.retryAfterSeconds = _data["retryAfterSeconds"];
            this.shouldChangeMobileNumber = _data["shouldChangeMobileNumber"];
            this.otpSent = _data["otpSent"];
            this.secondsRemaining = _data["secondsRemaining"];
            this.resultCode = _data["resultCode"];
            this.resultMessage = _data["resultMessage"];
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GenerateOTPOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateOTPOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRetry"] = this.canRetry;
        data["retryAfterSeconds"] = this.retryAfterSeconds;
        data["shouldChangeMobileNumber"] = this.shouldChangeMobileNumber;
        data["otpSent"] = this.otpSent;
        data["secondsRemaining"] = this.secondsRemaining;
        data["resultCode"] = this.resultCode;
        data["resultMessage"] = this.resultMessage;
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGenerateOTPOutputDto {
    canRetry: boolean;
    retryAfterSeconds: number;
    shouldChangeMobileNumber: boolean;
    otpSent: boolean;
    secondsRemaining: number;
    resultCode: string | undefined;
    resultMessage: string | undefined;
    returnStatus: ReturnStatusDto;
}

export class GetCaseAndActivitiesHistoryInputDto implements IGetCaseAndActivitiesHistoryInputDto {
    customerGuid!: string;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IGetCaseAndActivitiesHistoryInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerGuid = _data["customerGuid"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): GetCaseAndActivitiesHistoryInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCaseAndActivitiesHistoryInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGuid"] = this.customerGuid;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IGetCaseAndActivitiesHistoryInputDto {
    customerGuid: string;
    triggeredFrom: string;
    triggeredBy: string;
}

export class GetCaseAndActivitiesHistoryOutputDto implements IGetCaseAndActivitiesHistoryOutputDto {
    recentCaseHistory!: RecentCaseHistory[] | undefined;
    recentCallActivities!: RecentCallActivity[] | undefined;
    recentEmailActivities!: RecentEmailActivity[] | undefined;
    recentSMSActivities!: RecentSMSActivity[] | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: IGetCaseAndActivitiesHistoryOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["recentCaseHistory"])) {
                this.recentCaseHistory = [] as any;
                for (let item of _data["recentCaseHistory"])
                    this.recentCaseHistory!.push(RecentCaseHistory.fromJS(item));
            }
            if (Array.isArray(_data["recentCallActivities"])) {
                this.recentCallActivities = [] as any;
                for (let item of _data["recentCallActivities"])
                    this.recentCallActivities!.push(RecentCallActivity.fromJS(item));
            }
            if (Array.isArray(_data["recentEmailActivities"])) {
                this.recentEmailActivities = [] as any;
                for (let item of _data["recentEmailActivities"])
                    this.recentEmailActivities!.push(RecentEmailActivity.fromJS(item));
            }
            if (Array.isArray(_data["recentSMSActivities"])) {
                this.recentSMSActivities = [] as any;
                for (let item of _data["recentSMSActivities"])
                    this.recentSMSActivities!.push(RecentSMSActivity.fromJS(item));
            }
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCaseAndActivitiesHistoryOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCaseAndActivitiesHistoryOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recentCaseHistory)) {
            data["recentCaseHistory"] = [];
            for (let item of this.recentCaseHistory)
                data["recentCaseHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.recentCallActivities)) {
            data["recentCallActivities"] = [];
            for (let item of this.recentCallActivities)
                data["recentCallActivities"].push(item.toJSON());
        }
        if (Array.isArray(this.recentEmailActivities)) {
            data["recentEmailActivities"] = [];
            for (let item of this.recentEmailActivities)
                data["recentEmailActivities"].push(item.toJSON());
        }
        if (Array.isArray(this.recentSMSActivities)) {
            data["recentSMSActivities"] = [];
            for (let item of this.recentSMSActivities)
                data["recentSMSActivities"].push(item.toJSON());
        }
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCaseAndActivitiesHistoryOutputDto {
    recentCaseHistory: RecentCaseHistory[] | undefined;
    recentCallActivities: RecentCallActivity[] | undefined;
    recentEmailActivities: RecentEmailActivity[] | undefined;
    recentSMSActivities: RecentSMSActivity[] | undefined;
    returnStatus: ReturnStatusDto;
}

export class GetCategoryAndCriteriaOutputDto implements IGetCategoryAndCriteriaOutputDto {
    categories!: Category[] | undefined;
    adhocCriteria!: AdhocCriterion[] | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: IGetCategoryAndCriteriaOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["adhocCriteria"])) {
                this.adhocCriteria = [] as any;
                for (let item of _data["adhocCriteria"])
                    this.adhocCriteria!.push(AdhocCriterion.fromJS(item));
            }
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCategoryAndCriteriaOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCategoryAndCriteriaOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.adhocCriteria)) {
            data["adhocCriteria"] = [];
            for (let item of this.adhocCriteria)
                data["adhocCriteria"].push(item.toJSON());
        }
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCategoryAndCriteriaOutputDto {
    categories: Category[] | undefined;
    adhocCriteria: AdhocCriterion[] | undefined;
    returnStatus: ReturnStatusDto;
}

export class GetCustomerInputDto implements IGetCustomerInputDto {
    idNumber!: string | undefined;
    customerGUID!: string | undefined;
    spaAccountNumber!: string | undefined;
    anonymous!: boolean | undefined;
    dataSet!: DataSetEnum;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IGetCustomerInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.customerGUID = _data["customerGUID"];
            this.spaAccountNumber = _data["spaAccountNumber"];
            this.anonymous = _data["anonymous"];
            this.dataSet = _data["dataSet"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): GetCustomerInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["customerGUID"] = this.customerGUID;
        data["spaAccountNumber"] = this.spaAccountNumber;
        data["anonymous"] = this.anonymous;
        data["dataSet"] = this.dataSet;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IGetCustomerInputDto {
    idNumber: string | undefined;
    customerGUID: string | undefined;
    spaAccountNumber: string | undefined;
    anonymous: boolean | undefined;
    dataSet: DataSetEnum;
    triggeredFrom: string;
    triggeredBy: string;
}

export class GetCustomerOutputDto implements IGetCustomerOutputDto {
    salutation!: string | undefined;
    customerName!: string | undefined;
    customerGUID!: string | undefined;
    customerType!: string | undefined;
    accountNumber!: string | undefined;
    accountStatus!: string | undefined;
    customerNote!: string | undefined;
    emailAddress!: string | undefined;
    mobileNo!: string | undefined;
    homePhone!: any | undefined;
    residentialAddress!: string | undefined;
    idType!: string | undefined;
    idNumber!: string | undefined;
    finPassportExpiryDate!: string | undefined;
    dob!: string | undefined;
    gender!: string | undefined;
    statusFlags!: StatusFlagOutputDto[] | undefined;
    returnStatus!: ReturnStatusDto;

    constructor(data?: IGetCustomerOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.customerName = _data["customerName"];
            this.customerGUID = _data["customerGUID"];
            this.customerType = _data["customerType"];
            this.accountNumber = _data["accountNumber"];
            this.accountStatus = _data["accountStatus"];
            this.customerNote = _data["customerNote"];
            this.emailAddress = _data["emailAddress"];
            this.mobileNo = _data["mobileNo"];
            this.homePhone = _data["homePhone"];
            this.residentialAddress = _data["residentialAddress"];
            this.idType = _data["idType"];
            this.idNumber = _data["idNumber"];
            this.finPassportExpiryDate = _data["finPassportExpiryDate"];
            this.dob = _data["dob"];
            this.gender = _data["gender"];
            if (Array.isArray(_data["statusFlags"])) {
                this.statusFlags = [] as any;
                for (let item of _data["statusFlags"])
                    this.statusFlags!.push(StatusFlagOutputDto.fromJS(item));
            }
            this.returnStatus = _data["returnStatus"] ? ReturnStatusDto.fromJS(_data["returnStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["customerName"] = this.customerName;
        data["customerGUID"] = this.customerGUID;
        data["customerType"] = this.customerType;
        data["accountNumber"] = this.accountNumber;
        data["accountStatus"] = this.accountStatus;
        data["customerNote"] = this.customerNote;
        data["emailAddress"] = this.emailAddress;
        data["mobileNo"] = this.mobileNo;
        data["homePhone"] = this.homePhone;
        data["residentialAddress"] = this.residentialAddress;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["finPassportExpiryDate"] = this.finPassportExpiryDate;
        data["dob"] = this.dob;
        data["gender"] = this.gender;
        if (Array.isArray(this.statusFlags)) {
            data["statusFlags"] = [];
            for (let item of this.statusFlags)
                data["statusFlags"].push(item.toJSON());
        }
        data["returnStatus"] = this.returnStatus ? this.returnStatus.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCustomerOutputDto {
    salutation: string | undefined;
    customerName: string | undefined;
    customerGUID: string | undefined;
    customerType: string | undefined;
    accountNumber: string | undefined;
    accountStatus: string | undefined;
    customerNote: string | undefined;
    emailAddress: string | undefined;
    mobileNo: string | undefined;
    homePhone: any | undefined;
    residentialAddress: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    finPassportExpiryDate: string | undefined;
    dob: string | undefined;
    gender: string | undefined;
    statusFlags: StatusFlagOutputDto[] | undefined;
    returnStatus: ReturnStatusDto;
}

export class GetShortenedUrlInputDto implements IGetShortenedUrlInputDto {
    shortenedUrl!: string;

    constructor(data?: IGetShortenedUrlInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortenedUrl = _data["shortenedUrl"];
        }
    }

    static fromJS(data: any): GetShortenedUrlInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetShortenedUrlInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortenedUrl"] = this.shortenedUrl;
        return data;
    }
}

export interface IGetShortenedUrlInputDto {
    shortenedUrl: string;
}

export enum MessageCodeEnum {
    Failed = "Failed",
    ArgumentNullException = "ArgumentNullException",
    FieldLengthError = "FieldLengthError",
    AuthenticationError = "AuthenticationError",
    InvalidUrl = "InvalidUrl",
    Success = "Success",
    Created = "Created",
    Updated = "Updated",
}

export class RecentCallActivity implements IRecentCallActivity {
    dateTime!: string | undefined;
    subject!: string | undefined;
    callStatus!: string | undefined;
    owner!: string | undefined;

    constructor(data?: IRecentCallActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"];
            this.subject = _data["subject"];
            this.callStatus = _data["callStatus"];
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): RecentCallActivity {
        data = typeof data === 'object' ? data : {};
        let result = new RecentCallActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime;
        data["subject"] = this.subject;
        data["callStatus"] = this.callStatus;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IRecentCallActivity {
    dateTime: string | undefined;
    subject: string | undefined;
    callStatus: string | undefined;
    owner: string | undefined;
}

export class RecentCaseHistory implements IRecentCaseHistory {
    caseNumber!: string | undefined;
    caseTitle!: string | undefined;
    caseDetails!: string | undefined;
    owner!: string | undefined;
    statusReason!: string | undefined;

    constructor(data?: IRecentCaseHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseNumber = _data["caseNumber"];
            this.caseTitle = _data["caseTitle"];
            this.caseDetails = _data["caseDetails"];
            this.owner = _data["owner"];
            this.statusReason = _data["statusReason"];
        }
    }

    static fromJS(data: any): RecentCaseHistory {
        data = typeof data === 'object' ? data : {};
        let result = new RecentCaseHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseNumber"] = this.caseNumber;
        data["caseTitle"] = this.caseTitle;
        data["caseDetails"] = this.caseDetails;
        data["owner"] = this.owner;
        data["statusReason"] = this.statusReason;
        return data;
    }
}

export interface IRecentCaseHistory {
    caseNumber: string | undefined;
    caseTitle: string | undefined;
    caseDetails: string | undefined;
    owner: string | undefined;
    statusReason: string | undefined;
}

export class RecentEmailActivity implements IRecentEmailActivity {
    dateTime!: string | undefined;
    subject!: string | undefined;
    statusReason!: string | undefined;
    owner!: string | undefined;

    constructor(data?: IRecentEmailActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"];
            this.subject = _data["subject"];
            this.statusReason = _data["statusReason"];
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): RecentEmailActivity {
        data = typeof data === 'object' ? data : {};
        let result = new RecentEmailActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime;
        data["subject"] = this.subject;
        data["statusReason"] = this.statusReason;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IRecentEmailActivity {
    dateTime: string | undefined;
    subject: string | undefined;
    statusReason: string | undefined;
    owner: string | undefined;
}

export class RecentSMSActivity implements IRecentSMSActivity {
    dateTime!: string | undefined;
    subject!: string | undefined;
    smsMessage!: string | undefined;
    owner!: string | undefined;

    constructor(data?: IRecentSMSActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"];
            this.subject = _data["subject"];
            this.smsMessage = _data["smsMessage"];
            this.owner = _data["owner"];
        }
    }

    static fromJS(data: any): RecentSMSActivity {
        data = typeof data === 'object' ? data : {};
        let result = new RecentSMSActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime;
        data["subject"] = this.subject;
        data["smsMessage"] = this.smsMessage;
        data["owner"] = this.owner;
        return data;
    }
}

export interface IRecentSMSActivity {
    dateTime: string | undefined;
    subject: string | undefined;
    smsMessage: string | undefined;
    owner: string | undefined;
}

export class RetailContactSearchByContactInputDto implements IRetailContactSearchByContactInputDto {
    contact!: string;

    constructor(data?: IRetailContactSearchByContactInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
        }
    }

    static fromJS(data: any): RetailContactSearchByContactInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailContactSearchByContactInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        return data;
    }
}

export interface IRetailContactSearchByContactInputDto {
    contact: string;
}

export class RetailContactSearchByRetailInputDto implements IRetailContactSearchByRetailInputDto {
    retail!: string;

    constructor(data?: IRetailContactSearchByRetailInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retail = _data["retail"];
        }
    }

    static fromJS(data: any): RetailContactSearchByRetailInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailContactSearchByRetailInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retail"] = this.retail;
        return data;
    }
}

export interface IRetailContactSearchByRetailInputDto {
    retail: string;
}

export class RetailOutputDto implements IRetailOutputDto {
    retailerNo!: string;
    contactNos!: string | undefined;
    outletName!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    postalCode!: string | undefined;
    areaManager!: string | undefined;
    inCharge!: string | undefined;
    outletStaff!: string | undefined;
    emailAddress!: string | undefined;
    feInChargeByArea!: string | undefined;

    constructor(data?: IRetailOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retailerNo = _data["retailerNo"];
            this.contactNos = _data["contactNos"];
            this.outletName = _data["outletName"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.postalCode = _data["postalCode"];
            this.areaManager = _data["areaManager"];
            this.inCharge = _data["inCharge"];
            this.outletStaff = _data["outletStaff"];
            this.emailAddress = _data["emailAddress"];
            this.feInChargeByArea = _data["feInChargeByArea"];
        }
    }

    static fromJS(data: any): RetailOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailerNo"] = this.retailerNo;
        data["contactNos"] = this.contactNos;
        data["outletName"] = this.outletName;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["postalCode"] = this.postalCode;
        data["areaManager"] = this.areaManager;
        data["inCharge"] = this.inCharge;
        data["outletStaff"] = this.outletStaff;
        data["emailAddress"] = this.emailAddress;
        data["feInChargeByArea"] = this.feInChargeByArea;
        return data;
    }
}

export interface IRetailOutputDto {
    retailerNo: string;
    contactNos: string | undefined;
    outletName: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    postalCode: string | undefined;
    areaManager: string | undefined;
    inCharge: string | undefined;
    outletStaff: string | undefined;
    emailAddress: string | undefined;
    feInChargeByArea: string | undefined;
}

export class ReturnStatusDto implements IReturnStatusDto {
    message!: string | undefined;
    messageCode!: MessageCodeEnum;

    constructor(data?: IReturnStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): ReturnStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["messageCode"] = this.messageCode;
        return data;
    }
}

export interface IReturnStatusDto {
    message: string | undefined;
    messageCode: MessageCodeEnum;
}

export class ShortenUpdateCaseUrlDto implements IShortenUpdateCaseUrlDto {
    systemAuthenticatedNAReason!: string | undefined;
    caseTitle!: string | undefined;
    authToken!: string | undefined;
    ipccCallExtensionID!: string | undefined;
    contactMode!: string | undefined;
    customerIsAnonymous!: string | undefined;
    caseId!: string;
    customerId!: string | undefined;
    customerAccountNumber!: string | undefined;
    agentName!: string | undefined;
    agentUsername!: string | undefined;
    customerIsAuthenticated!: string | undefined;

    constructor(data?: IShortenUpdateCaseUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemAuthenticatedNAReason = _data["systemAuthenticatedNAReason"];
            this.caseTitle = _data["caseTitle"];
            this.authToken = _data["authToken"];
            this.ipccCallExtensionID = _data["ipccCallExtensionID"];
            this.contactMode = _data["contactMode"];
            this.customerIsAnonymous = _data["customerIsAnonymous"];
            this.caseId = _data["caseId"];
            this.customerId = _data["customerId"];
            this.customerAccountNumber = _data["customerAccountNumber"];
            this.agentName = _data["agentName"];
            this.agentUsername = _data["agentUsername"];
            this.customerIsAuthenticated = _data["customerIsAuthenticated"];
        }
    }

    static fromJS(data: any): ShortenUpdateCaseUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortenUpdateCaseUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemAuthenticatedNAReason"] = this.systemAuthenticatedNAReason;
        data["caseTitle"] = this.caseTitle;
        data["authToken"] = this.authToken;
        data["ipccCallExtensionID"] = this.ipccCallExtensionID;
        data["contactMode"] = this.contactMode;
        data["customerIsAnonymous"] = this.customerIsAnonymous;
        data["caseId"] = this.caseId;
        data["customerId"] = this.customerId;
        data["customerAccountNumber"] = this.customerAccountNumber;
        data["agentName"] = this.agentName;
        data["agentUsername"] = this.agentUsername;
        data["customerIsAuthenticated"] = this.customerIsAuthenticated;
        return data;
    }
}

export interface IShortenUpdateCaseUrlDto {
    systemAuthenticatedNAReason: string | undefined;
    caseTitle: string | undefined;
    authToken: string | undefined;
    ipccCallExtensionID: string | undefined;
    contactMode: string | undefined;
    customerIsAnonymous: string | undefined;
    caseId: string;
    customerId: string | undefined;
    customerAccountNumber: string | undefined;
    agentName: string | undefined;
    agentUsername: string | undefined;
    customerIsAuthenticated: string | undefined;
}

export class StatusFlagDto implements IStatusFlagDto {
    code!: string;
    description!: string;

    constructor(data?: IStatusFlagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): StatusFlagDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusFlagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export interface IStatusFlagDto {
    code: string;
    description: string;
}

export class StatusFlagOutputDto implements IStatusFlagOutputDto {
    statusFlag!: string | undefined;
    statusName!: string | undefined;
    statusChangedReason!: string | undefined;

    constructor(data?: IStatusFlagOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusFlag = _data["statusFlag"];
            this.statusName = _data["statusName"];
            this.statusChangedReason = _data["statusChangedReason"];
        }
    }

    static fromJS(data: any): StatusFlagOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusFlagOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusFlag"] = this.statusFlag;
        data["statusName"] = this.statusName;
        data["statusChangedReason"] = this.statusChangedReason;
        return data;
    }
}

export interface IStatusFlagOutputDto {
    statusFlag: string | undefined;
    statusName: string | undefined;
    statusChangedReason: string | undefined;
}

export class UpdateCaseAutoSaveInputDto implements IUpdateCaseAutoSaveInputDto {
    customerGUID!: string | undefined;
    caseTitle!: string | undefined;
    caseDetails!: string | undefined;
    systemAuthenticated!: boolean | undefined;
    manualVerification!: boolean | undefined;
    ipccCallExtensionID!: string | undefined;
    owner!: string | undefined;
    caseCategory1!: string | undefined;
    caseCategory2!: string | undefined;
    caseCategory3!: string | undefined;
    adHocCriteria!: string | undefined;
    followupAction!: string | undefined;
    contactMode!: ContactModeInputEnum;
    modifiedBy!: string | undefined;
    followupRequired!: boolean | undefined;
    caseStatus!: CaseStatusInputEnum;
    resolution!: string | undefined;
    triggeredFrom!: string | undefined;
    triggeredBy!: string | undefined;

    constructor(data?: IUpdateCaseAutoSaveInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerGUID = _data["customerGUID"];
            this.caseTitle = _data["caseTitle"];
            this.caseDetails = _data["caseDetails"];
            this.systemAuthenticated = _data["systemAuthenticated"];
            this.manualVerification = _data["manualVerification"];
            this.ipccCallExtensionID = _data["ipccCallExtensionID"];
            this.owner = _data["owner"];
            this.caseCategory1 = _data["caseCategory1"];
            this.caseCategory2 = _data["caseCategory2"];
            this.caseCategory3 = _data["caseCategory3"];
            this.adHocCriteria = _data["adHocCriteria"];
            this.followupAction = _data["followupAction"];
            this.contactMode = _data["contactMode"];
            this.modifiedBy = _data["modifiedBy"];
            this.followupRequired = _data["followupRequired"];
            this.caseStatus = _data["caseStatus"];
            this.resolution = _data["resolution"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): UpdateCaseAutoSaveInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseAutoSaveInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGUID"] = this.customerGUID;
        data["caseTitle"] = this.caseTitle;
        data["caseDetails"] = this.caseDetails;
        data["systemAuthenticated"] = this.systemAuthenticated;
        data["manualVerification"] = this.manualVerification;
        data["ipccCallExtensionID"] = this.ipccCallExtensionID;
        data["owner"] = this.owner;
        data["caseCategory1"] = this.caseCategory1;
        data["caseCategory2"] = this.caseCategory2;
        data["caseCategory3"] = this.caseCategory3;
        data["adHocCriteria"] = this.adHocCriteria;
        data["followupAction"] = this.followupAction;
        data["contactMode"] = this.contactMode;
        data["modifiedBy"] = this.modifiedBy;
        data["followupRequired"] = this.followupRequired;
        data["caseStatus"] = this.caseStatus;
        data["resolution"] = this.resolution;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IUpdateCaseAutoSaveInputDto {
    customerGUID: string | undefined;
    caseTitle: string | undefined;
    caseDetails: string | undefined;
    systemAuthenticated: boolean | undefined;
    manualVerification: boolean | undefined;
    ipccCallExtensionID: string | undefined;
    owner: string | undefined;
    caseCategory1: string | undefined;
    caseCategory2: string | undefined;
    caseCategory3: string | undefined;
    adHocCriteria: string | undefined;
    followupAction: string | undefined;
    contactMode: ContactModeInputEnum;
    modifiedBy: string | undefined;
    followupRequired: boolean | undefined;
    caseStatus: CaseStatusInputEnum;
    resolution: string | undefined;
    triggeredFrom: string | undefined;
    triggeredBy: string | undefined;
}

export class UpdateCaseInputDto implements IUpdateCaseInputDto {
    caseID!: string;
    customerGUID!: string;
    caseTitle!: string;
    caseDetails!: string;
    systemAuthenticated!: boolean;
    manualVerification!: boolean;
    ipccCallExtensionID!: string;
    owner!: string;
    caseCategory1!: string;
    caseCategory2!: string;
    caseCategory3!: string;
    adHocCriteria!: string | undefined;
    followupAction!: string;
    contactMode!: ContactModeInputEnum;
    modifiedBy!: string;
    followupRequired!: boolean;
    caseStatus!: CaseStatusInputEnum;
    resolution!: string | undefined;
    triggeredFrom!: string;
    triggeredBy!: string;

    constructor(data?: IUpdateCaseInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseID = _data["caseID"];
            this.customerGUID = _data["customerGUID"];
            this.caseTitle = _data["caseTitle"];
            this.caseDetails = _data["caseDetails"];
            this.systemAuthenticated = _data["systemAuthenticated"];
            this.manualVerification = _data["manualVerification"];
            this.ipccCallExtensionID = _data["ipccCallExtensionID"];
            this.owner = _data["owner"];
            this.caseCategory1 = _data["caseCategory1"];
            this.caseCategory2 = _data["caseCategory2"];
            this.caseCategory3 = _data["caseCategory3"];
            this.adHocCriteria = _data["adHocCriteria"];
            this.followupAction = _data["followupAction"];
            this.contactMode = _data["contactMode"];
            this.modifiedBy = _data["modifiedBy"];
            this.followupRequired = _data["followupRequired"];
            this.caseStatus = _data["caseStatus"];
            this.resolution = _data["resolution"];
            this.triggeredFrom = _data["triggeredFrom"];
            this.triggeredBy = _data["triggeredBy"];
        }
    }

    static fromJS(data: any): UpdateCaseInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseID"] = this.caseID;
        data["customerGUID"] = this.customerGUID;
        data["caseTitle"] = this.caseTitle;
        data["caseDetails"] = this.caseDetails;
        data["systemAuthenticated"] = this.systemAuthenticated;
        data["manualVerification"] = this.manualVerification;
        data["ipccCallExtensionID"] = this.ipccCallExtensionID;
        data["owner"] = this.owner;
        data["caseCategory1"] = this.caseCategory1;
        data["caseCategory2"] = this.caseCategory2;
        data["caseCategory3"] = this.caseCategory3;
        data["adHocCriteria"] = this.adHocCriteria;
        data["followupAction"] = this.followupAction;
        data["contactMode"] = this.contactMode;
        data["modifiedBy"] = this.modifiedBy;
        data["followupRequired"] = this.followupRequired;
        data["caseStatus"] = this.caseStatus;
        data["resolution"] = this.resolution;
        data["triggeredFrom"] = this.triggeredFrom;
        data["triggeredBy"] = this.triggeredBy;
        return data;
    }
}

export interface IUpdateCaseInputDto {
    caseID: string;
    customerGUID: string;
    caseTitle: string;
    caseDetails: string;
    systemAuthenticated: boolean;
    manualVerification: boolean;
    ipccCallExtensionID: string;
    owner: string;
    caseCategory1: string;
    caseCategory2: string;
    caseCategory3: string;
    adHocCriteria: string | undefined;
    followupAction: string;
    contactMode: ContactModeInputEnum;
    modifiedBy: string;
    followupRequired: boolean;
    caseStatus: CaseStatusInputEnum;
    resolution: string | undefined;
    triggeredFrom: string;
    triggeredBy: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}